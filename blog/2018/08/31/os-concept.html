<!doctype html>
<html>
<head>
	
	<title>操作系统：基本概念</title>
	<meta name="keywords" content="wandaima.org,玩代码,程序员,博客" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('/css/mobile.css', 'css');
            } else {
                loadjscssfile('/css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=3"/>
    
    

</head>

<body>


<h2 class="title">操作系统：基本概念</h2>

<h3 id="操作系统是什么"><a href="#操作系统是什么" class="headerlink" title="操作系统是什么"></a>操作系统是什么</h3><p>&emsp;&emsp;操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机“上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。<br>&emsp;&emsp;简单来说，OS就是封装了底层硬件的各种对人不友好的接口，然后提供对人更加友好的接口（API），也叫系统调用。现代操作系统的基本功能包括：进程管理、内存管理、文件系统、网络通讯、安全机制、用户交互、驱动程序。</p>
<h3 id="x86计算机启动过程"><a href="#x86计算机启动过程" class="headerlink" title="x86计算机启动过程"></a>x86计算机启动过程</h3><p>&emsp;&emsp;我们知道，计算机开机的时候会先执行BIOS（Basic Input Output System）。实际上，在开机上电的一瞬间，CPU的CS：IP被强制初始化为0xf000：0xfff0，因为x86内存寻址是采用”段基址：段内偏移地址“的形式，所以CS：IP实际指向的物理地址是0xf000 * 16 + 0xfff0 = 0xffff0，在实模式下CPU只能访问1MB的内存空间（0~0xfffff），0xffff0距离1MB的终点只有16字节，这不可能放得下整个BIOS代码。所以，其实0xffff0地址处只是一条跳转指令（ljmp 0xf000：0xe05b），即跳转到0xfe05b，这才是BIOS代码真正执行的物理地址。<br>&emsp;&emsp;BIOS由于代码空间有限，只会对一些系统基本且必要的硬件进行检测和初始化，如检测内存、显卡等，并建立中断向量表（BIOS中断），因此称为基本输入输出系统。BIOS最后一项工作是将系统控制权交给MBR（Main Boot Record，主引导记录）。MBR位于磁盘最开始的那个扇区，CHS方法是0盘0道1扇区，LBA方法是0盘0道0扇区，该扇区约定必须以0x55和0xaa结尾，否则会报找不到MBR的错误。BIOS如果找到了MBR，那么就将MBR从磁盘加载到物理内存的0x0000：0x7c00处，然后跳转到该处执行，即jmp 0x0000：0x7c000。至此，BIOS终于完成了它的使命。<br>&emsp;&emsp;至于为什么是0x7c00这个这个数字，我想不止我有这样的好奇心。据说，MBR程序本身只有512字节，但运行时需要栈空间，实际所用的内存空间是大于512字节的，不过一般1KB就够用了。最早的BIOS是按照最小内存32KB开发的，为了防止MBR被其他程序覆盖，MBR只能放在32KB的末尾，32KB（0x8000）减去1KB就是0x7c00。</p>
<h3 id="X86实模式和保护模式"><a href="#X86实模式和保护模式" class="headerlink" title="X86实模式和保护模式"></a>X86实模式和保护模式</h3><p>&emsp;&emsp;x86的内存寻址是通过段寄存器的值加上偏移地址形成物理地址来寻址的。16位寄存器的寻址空间是64KB，可是当时地址总线已经到20位了，在不改变段寄存器位数的情况下，为了能有更大的寻址空间，英特尔工程师当时就想了一个办法：由16位段寄存器的值乘以16当做段基址，加上16位偏移地址，这样就形成了20位的物理地址，寻址空间就达到了1MB。<br>&emsp;&emsp;可是，这样又会引出一个问题：内存寻址是采用”段基址：段内偏移地址“的形式，即段基址乘以16加上段内偏移地址，如果段基址和段内偏移都为16位的最大值，即0xffff：0xffff，最大寻址地址是0xffff0+0xffff=0x10ffef。由于20位地址线的最大寻址空间是1MB，即0x00000~0xfffff，超出1MB内存的部分在物理上没有对应的地址。为了解决这个问题，CPU的做法是地址回绕，即把地址对1MB求模。超出1MB的内存被称为高端内存区（HMA）。<br>&emsp;&emsp;以上是在实模式下发生的事情。事实上，CPU复位或者加电的时候都是以实模式启动的。在实模式下，所有的段都是可读、可写和可执行的，这是很不安全的。因为操作系统和用户程序无法区分开，用户可以访问、修改任何内存地址；除此之外，实模式下能访问的地址空间太小了。因此，必须想办法解决这个问题。我们知道，x86的内存寻址是“段基址：段内偏移”形式的，因此可以想法设法对段基址和段内偏移加一些限制（比如段的大小、范围等）；另外，为了能访问更大的地址空间，16位的寄存器肯定不够用了，因此把寄存器位数直接扩展到32位，这样就可以访问4GB的地址空间了，足够用了。虽然其他寄存器都扩展到32位了，但是段寄存器还是16位的，因为对于选择子来说已经够用了，现在不用了解太多，后面讲到段描述符时会讲到选择子的。<br>&emsp;&emsp;我们来聊聊保护模式吧。首先，实模式的CPU运行环境是16位，保护模式的CPU运行环境是32位。意思就是，在实模式下，CPU使用的寄存器和指令等默认都是16位的（当然也可以用32位的）；在保护模式下，CPU使用的寄存器和指令等默认都是32位（当然也可以用16位的）。保护模式相对于实模式有四种变化：<br>（1）寄存器扩展<br>&emsp;&emsp;在保护模式下，寄存器被扩展到了32位，如下图：<br><img src="/images/os-concept-01.png" width="90%" height="90%" /><br>（2）寻址扩展<br>&emsp;&emsp;实模式下的寻址方式：<br><img src="/images/os-concept-02.png" width="90%" height="90%" /><br>&emsp;&emsp;保护模式下的寻址方式：<br><img src="/images/os-concept-03.png" width="90%" height="90%" /><br>（3）运行模式反转<br>&emsp;&emsp;CPU的指令格式是：</p>
<p><table style="width: 98%; margin: 0 2%"><tr><td>前缀</td><td>操作码</td><td>寻址方式/操作数类型</td><td>立即数</td><td>偏移量</td></tr></table><br>&emsp;&emsp;因为实模式和保护模式的寄存器和寻址方式都不同，因此为了兼容两种模式，需要告诉编译器哪些指令是16位或32位的。在汇编中，[bits 16]或[bits 32]分别告诉编译器以下代码编译成16位或32位。bits指令的范围是从当前bits到下一个bits。在未使用bits指令的地方，默认是[bits 16]。<br>&emsp;&emsp;操作数反转前缀0x66的含义是：仅在当前指令，如果当前运行模式是16位实模式，操作数将变为32位；如果当前运行模式是32位保护模式，操作数将变为16位。<br>&emsp;&emsp;寻址方式反转前缀0x67的含义是：如果在指令中使用了非当前运行模式的操作数、寄存器、寻址方式，那么就会添加前缀0x67。<br>（4）指令扩展<br>&emsp;&emsp;指令扩展<br>&emsp;&emsp;待续。。。（尽量每日更新）</p>


<div style="display:none">
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1274594875'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1274594875%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</div>






</body>
</html>